---
title: "C2.TCR.integration"
author: "Nick Borcherding"
date: "10/27/2020"
output: html_document
---
```{r}
library(scRepertoire)
library(stringr)
library(stringdist)
library(parallel)
library(pbmcapply)
library(vegan)
library(igraph)

source("./R/functions.R")
setwd("~/Documents/GitHub/lg_dataAnalysis")

colorblind_vector <- colorRampPalette(c("#FF4B20", "#FFB433", "#C6FDEC", "#7AC5FF", "#0348A6"))
```

```{r}
load("./data/pbmcControls.rda")
controls <- getTCR(pbmc)

sampleControl_gc <- function(i, edit.distance) {
    con <- controls[sample(nrow(controls), 1000),]
    con2 <- rbind.data.frame(pbmc[pbmc[,c("cdr3_aa1")] %in% con$Var1,],
                            pbmc[pbmc[,c("cdr3_aa2")] %in% con$Var1,])
    con2 <- con2[sample(nrow(con2), 1000),]
    gc_con <- globalConvergence(con2, edit.distance = i)
    gc_con <- checkVgenes(gc_con, controls)
    y <- nrow(gc_con)
}


controls <- getTCR(pbmc)
edit.distances <- list()
for (i in 1:5) {
    sampleControl_gc <- function(x) {
        con <- controls[sample(nrow(controls), 1000),]
        con2 <- rbind.data.frame(pbmc[pbmc[,c("cdr3_aa1")] %in% con$Var1,],
                                pbmc[pbmc[,c("cdr3_aa2")] %in% con$Var1,])
        con2 <- con2[sample(nrow(con2), 1000),]
        gc_con <- globalConvergence(con2, edit.distance = i)
        gc_con <- checkVgenes(gc_con, controls)
        y <- nrow(gc_con)
        }
    
    bootstrap_gc <- pbmclapply(1:1000, sampleControl_gc, mc.cores = 2)
    edit.distances[[i]] <- unlist(bootstrap_gc)
}

save(edit.distances, file = "bootstrap_LV_Integers1.5.rda")

library(tidyr)


localConvergence2 <- function(con2, motif.length = l) {
    comb <- t(combn(rep(c("A", "R", "N", "D", "C", "Q", "E", "G", "H", "I", "L", "K", "M", "F", "P", "S", "T", "W", "Y", "V"), l), l))
    comb <- as.data.frame(unique(comb))
    comb <- unite(comb, "comb", sep = "")
    TCR <- getTCR(con2)
    positions <- NULL
    vgenes <- unique(TCR[,4])
    for (h in seq_along(vgenes)) {
        subset <- TCR[TCR$v %in% vgenes[h],]
        out <- matrix(nrow = nrow(subset), ncol =length(comb$comb), 0)
        colnames(out) <- comb$comb
        rownames(out) <- subset$Var1
    
        for (i in seq_len(nrow(subset))) {
            seq <- as.character(subset$Var1[i])
            index <- seq_len(nchar(seq))
            index <- index[-c(1,2,3, nchar(seq)-2, nchar(seq)-1, nchar(seq))]
            for (j in index) {
                string <- substr(seq, j+3, j+(motif.length-1)+3)
                if (string %in% comb$comb & nchar(string) == motif.length) {
                    position <- which(colnames(out) == string)
                    out[i,position] <- out[i,position] + 1
                } else {
                    next()
                }
            }
        }

    out[out == 0] <- NA
    positions_motif <- getPostitions(out, 0,9)
    motifs <- unique(positions_motif[,2])
    df.edge <- NULL
    for (k in seq_along(motifs)) {
        correspond <- positions_motif[positions_motif[,2] == motifs[k],]
        if (length(correspond) == 2) {
            next()
        }
        out <- t(combn(c(correspond[,1], correspond[,1]), 2))
        out <- unique(out)
        out <- out[out[,1] != out[,2],]
        To <- as.character(subset$Var1)[out[,1]]
        From <- as.character(subset$Var1)[out[,2]]
        out <- data.frame(To,From, spec.Motif = comb$comb[motifs[k]])
        df.edge <- rbind(df.edge, out)
        }
    positions <- rbind(positions, df.edge)
    }
    positions<- unique(positions)
    positions <- as.data.frame(table(positions$spec.Motif))
    return(positions)
}


motif.distances <- list()
count <- 1
for(l in 2:4) {
    sampleControl_lc <- function(x) {
        con <- controls[sample(nrow(controls), 1000),]
        con2 <- rbind.data.frame(pbmc[pbmc[,c("cdr3_aa1")] %in% con$Var1,],
                             pbmc[pbmc[,c("cdr3_aa2")] %in% con$Var1,])
        con2 <- con2[sample(nrow(con2), 1000),]
        lc_con <- localConvergence2(con2, motif.length = l)
    }
    
    bootstrap_lc <- pbmclapply(1:1000, sampleControl_lc, mc.cores = 2)
    motif.distances[[count]] <- bootstrap_lc
    count <- count + 1
    
}

save(motif.distances, file = "bootstrap_motif_Integers2.4.rda")
    

```

```{r}
###################################
#Load Data
##################################
file_list <- list.files("./data/")
file_list <- file_list <- file_list[!grepl(".rda|.rds|.txt", file_list)]

contig_list <- list()
for (i in seq_along(file_list)){
    contig_list[[i]] <- read.csv(paste0("./data/", file_list[i], "/filtered_contig_annotations.csv"))
}

names(contig_list) <- file_list

###Need to remove prefixes of these samples that were added previously
for (i in c(4,5,6, 13,14,15)) {
    contig_list[[i]]$barcode <- substr(contig_list[[i]]$barcode, 11, 28)
}
```


```{r}
###################################
#Combine Contigs
###################################
combined <- combineTCR(contig_list, samples = file_list, ID = rep("1", 15), cells = c("T-AB"), filterMulti = T, removeNA = T)

for (i in seq_along(combined)) {
    combined[[i]]$barcode <- gsub(names(combined)[i], file_list[i], combined[[i]]$barcode)
}

combined <- addVariable(combined, "Patient", c("Pt1", "Pt2", "Pt3", "Pt4", "Pt5", "Pt6", "Pt1", "Pt2", "Pt3", "Pt1", "Pt2", "Pt3", "Pt4", "Pt5", "Pt6"))
```

```{r}
combined <- combined[-c(4:15)] 
```




    
```{r}
testRun <- calculateConvergence(combined, chain = "TCRB", group = "Patient", 
                          motif.length = 3, num.cores =3, boot.straps = 1000, 
                          edit.distance = 1, p.value.motif = 0.005, fc.motif = 5,
                          score.cluster = TRUE)


```


Need to add 1) cluster size probability

Think on the global and local convergence p-values






