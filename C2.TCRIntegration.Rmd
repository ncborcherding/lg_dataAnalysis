---
title: "C2.TCR.integration"
author: "Nick Borcherding"
date: "10/27/2020"
output: html_document
---
```{r}
library(scRepertoire)
library(stringr)
library(stringdist)
library(parallel)
library(pbmcapply)

source("./R/functions.R")
setwd("~/Documents/GitHub/lg_dataAnalysis")

colorblind_vector <- colorRampPalette(c("#FF4B20", "#FFB433", "#C6FDEC", "#7AC5FF", "#0348A6"))
```


```{r}
###################################
#Load Data
##################################
file_list <- list.files("./data/")
file_list <- file_list <- file_list[!grepl(".rda|.rds", file_list)]

contig_list <- list()
for (i in seq_along(file_list)){
    contig_list[[i]] <- read.csv(paste0("./data/", file_list[i], "/filtered_contig_annotations.csv"))
}

names(contig_list) <- file_list

###Need to remove prefixes of these samples that were added previously
for (i in c(4,5,6, 13,14,15)) {
    contig_list[[i]]$barcode <- substr(contig_list[[i]]$barcode, 11, 28)
}
```


```{r}
###################################
#Combine Contigs
###################################
combined <- combineTCR(contig_list, samples = file_list, ID = rep("1", 15), cells = c("T-AB"), filterMulti = T, removeNA = T)

for (i in seq_along(combined)) {
    combined[[i]]$barcode <- gsub(names(combined)[i], file_list[i], combined[[i]]$barcode)
}

combined <- addVariable(combined, "Patient", c("Pt1", "Pt2", "Pt3", "Pt4", "Pt5", "Pt6", "Pt1", "Pt2", "Pt3", "Pt1", "Pt2", "Pt3", "Pt4", "Pt5", "Pt6"))
```


    
```{r}
testRun <- calculateConvergence(combined, chain = "TCRB", group = "Patient", 
                          motif.length = 3, num.cores =3, boot.straps = 1000, 
                          edit.distance = 1, p.value.motif = 0.005, fc.motif = 5)
```


Need to add 1) cluster size probability

Think on the global and local convergence p-values

```{r}
library(vegan)
message(paste("Calculating Cluster Probabilities", names(tmp.list)[x]))
scoreCluster <- function(convergence) {
    for (i in seq_along(convergence)) {
    tmp <- convergence[[i]][[1]]
    cluster <- unique(tmp$TCRcluster)
        for (j in seq_along(cluster)) {
            sub <- tmp[tmp$TCRcluster == cluster,]
            
            #Probability of randomly length diversity
            #somewhat biased because of the selection of vgenes
            vgene.diversity <- vgeneDiversity(sub)
            vgene.diversity.perm <- unlist(lapply(1:1000, vgeneDiversity.perm))
            pVgene <- probabilityFun(vgene.diversity, vgene.diversity.perm)
            
            #Probability of randomly length diversity
            length.diversity <- diversity(sub[,"length"], index = "simpson")
            length.diversity.perm <- unlist(lapply(1:1000, vgeneDiversity.perm))
            pLength <- probabilityFun(length.diversity, length.diversity.perm)
            
            #Probability of randomly sampled frequences
            freq.size <-  length(unique(names(table(sub[,cdr3]))))/nrow(sub)
            freq.size.perm <- unlist(lapply(1:1000, freq.perm))
            pFreq <- probabilityFun(freq.size, freq.size.perm)
            
            #mean motif p-values for cluster
            ####May need to rethink this
            pLC <- mean(sub[,ncol(sub)])
            
            #probability of global similarity
            ####May need to rethink this
            pGC <- probabilityFun(nrow(positions_LV), unlist(bootstrap_gc))
            
            if(any(list(pVgene, pLength, pFreq, pLC, pGC) == 0)) {
                vars <- which(list(pVgene, pLength, pFreq, pLC, pGC) == 0)
                for (k in vars) {
                    p <- list(pVgene, pLength, pFreq, pLC, pGC)[[k]] 
                    varia <- c("pVgene", "pLength", "pFreq", "pLC", "pGC")[k] 
                    p <- 0.001
                    assign(varia, p)
                }
            }
            prob <- (pLC * pGC * pVgene *pLength * pFreq) / 
                ((pLC * pGC * pVgene *pLength * pFreq) + 
                ((1-pLC) * (1-pGC) * (1-pVgene) * (1-pLength) * (1-pFreq)))
        }
        
    }
    
}
```


```{r}
x <- rawToChar(as.raw(177))
x
strtoi(as.strin sub[,"vgene"],) # Polish "a with ogonek"
str_conv(x, "ISO-8859-1") # Plus-minus
```

```{r}
y <- tmp$cdr3_aa2
y <- unique(y)
align <-  msa(y, type = "protein", gapOpening = 15)
align2 <- msaConvert(align, type="ape::AAbin")

y <- as.AAbin.character(y, j = length(y))
df <- data.frame(cdr3 = y, scaled.distance = dist.aa(align2, scaled = TRUE))
z <- dist.aa(align2, scaled = TRUE)
test <- bind_rows(testRun)

data(woodmouse)
AA <- trans(woodmouse, 2)
```

GLIPH then scores each individual cluster (candidate convergence group) by evaluating a
set of features that are independet of the CDR3 observations, assigning a probability 
p to each feature, and then combining those probabilities into a single score by conflation. 

For tests i through N, testing Pi(X=C) probability that cluster X is convergent, the combined
conflation score is given as

                      __N
P(X=C) =              ||  P (X=C)
                        i  i
           ----------------------------
            __N             __N
            ||  P (X=C)  +  ||  P (X!=C)
              i  i            i  i

The individual Pi(X=C) tests include 

1) global similarity probability
2) local motif probability
3) network size
4) enrichment of V-gene within cluster
5) enrichment of CDR3 length (spectratype) within cluster
6) enrichment of clonal expansion within cluster
7) enrichment of common HLA among donor TCR contributors in cluster 

Individual score components are calculated as follows:

== 3) Calculating network size p ==

For each discrete cluster, the probability p of a given cluster topology can be 
obtained from the number of members of the cluster by comparison to a lookup table 
calculated from repeat random sampling and GLIPH clustering of naive TCR sequences 
at a range of different sampling depths n from 25 to 5000, each performed 1000 times 
each. 

Example: at sampling depth n=500, clusters of size 5 have a probabilty p=0.002 of occuring
in naive TCR sample sets.


