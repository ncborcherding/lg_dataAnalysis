p <- function(v) {
Reduce(f=paste0, x = v)
}
motifs <- positions_motif %>%
group_by(To) %>%
mutate(filtered_motifs=p(spec.Motif))
motifs[1,]
class(motifs[1,"filtered_motifs"])
class(motifs[,"filtered_motifs"])
class(motifs$filtered_motifs)
motifs <- positions_motif %>%
group_by(To, spec.motif) %>%
mutate(filtered_motifs=p(spec.Motif))
motifs <- positions_motif %>%
group_by(To, spec.Motif) %>%
mutate(filtered_motifs=p(spec.Motif))
motifs[1,]
p <- function(v) {
Reduce(f=paste, x = v)
}
motifs <- positions_motif %>%
group_by(To, spec.Motif) %>%
mutate(filtered_motifs=p(spec.Motif))
motifs[1,]
p <- function(v) {
Reduce(f=uniuqe(paste), x = v)
}
motifs <- positions_motif %>%
group_by(To, spec.Motif) %>%
mutate(filtered_motifs=p(spec.Motif))
motifs <- positions_motif %>%
group_by(To) %>%
mutate(filtered_motifs=p(spec.Motif))
Reduce(f=unique(paste), x = v)
p <- function(v) {
Reduce(f=unique(paste), x = v)
}
motifs <- positions_motif %>%
group_by(To) %>%
mutate(filtered_motifs=p(spec.Motif))
reduce2(f=paste, x = v, y = unique)
library(purrr)
p <- function(v) {
reduce2(f=paste, x = v, y = unique)
}
motifs <- positions_motif %>%
group_by(To) %>%
mutate(filtered_motifs=p(spec.Motif))
p <- function(v) {
reduce2(f=paste, x = v)
}
motifs <- positions_motif %>%
group_by(To) %>%
mutate(filtered_motifs=p(spec.Motif))
p <- function(v) {
Reduce(f=paste, x = v)
}
motifs <- positions_motif %>%
group_by(To) %>%
mutate(filtered_motifs=p(spec.Motif))
View(motifs)
motifs <- positions_motif %>%
group_by(To) %>%
summarise(cc = paste(unique(spec.Motif), collapse = ','))
View(motifs)
View(motifs)
View(membership)
membership <- merge(membership, motifs, by.x = "cdr3", by.y = "To")
View(membership)
View(tmp)
test <- merge(tmp, membership, by.x = chainCheck(chain)[[1]], by.y = "cdr3")
View(test)
positions <- positions_LV
i <- 1
a <- positions[i,"To"]
b <- positions[i,"From"]
x <- TCR[which(TCR[,"Var1"] == a), "vgene"]
y <- TCR[which(TCR[,"Var1"] == b), "vgene"]
if (x == y) {
next()
} else {
count <- c(count,i)
}
a <- positions[i,"To"]
b <- positions[i,"From"]
i <- 2
a <- positions[i,"To"]
b <- positions[i,"From"]
x <- TCR[which(TCR[,"Var1"] == a), "vgene"]
y <- TCR[which(TCR[,"Var1"] == b), "vgene"]
count <- c(count,i)
View(count)
count <- NULL
count <- c(count,i)
i <- 3
a <- positions[i,"To"]
b <- positions[i,"From"]
x <- TCR[which(TCR[,"Var1"] == a), "vgene"]
y <- TCR[which(TCR[,"Var1"] == b), "vgene"]
count <- c(count,i)
i <- 5
a <- positions[i,"To"]
b <- positions[i,"From"]
x <- TCR[which(TCR[,"Var1"] == a), "vgene"]
y <- TCR[which(TCR[,"Var1"] == b), "vgene"]
count <- c(count,i)
i <- 4
a <- positions[i,"To"]
b <- positions[i,"From"]
x <- TCR[which(TCR[,"Var1"] == a), "vgene"]
y <- TCR[which(TCR[,"Var1"] == b), "vgene"]
i <- 6
a <- positions[i,"To"]
b <- positions[i,"From"]
x <- TCR[which(TCR[,"Var1"] == a), "vgene"]
y <- TCR[which(TCR[,"Var1"] == b), "vgene"]
count <- c(count,i)
i <- 7
a <- positions[i,"To"]
b <- positions[i,"From"]
x <- TCR[which(TCR[,"Var1"] == a), "vgene"]
y <- TCR[which(TCR[,"Var1"] == b), "vgene"]
i <- 8
a <- positions[i,"To"]
b <- positions[i,"From"]
x <- TCR[which(TCR[,"Var1"] == a), "vgene"]
y <- TCR[which(TCR[,"Var1"] == b), "vgene"]
a <- positions[i,"To"]
b <- positions[i,"From"]
View(positions)
x <- TCR[which(TCR[,"Var1"] == a), "vgene"]
y <- TCR[which(TCR[,"Var1"] == b), "vgene"]
x == y
if (x == y)
positions <- positions[-count,]
positions_LV <- checkVgenes(positions_LV, TCR)
positions_LV <- globalConvergence(tmp, chain = chain)
positions_LV <- checkVgenes(positions_LV, TCR)
View(positions_LV)
positions_LV <- globalConvergence(tmp, chain = chain)
checkVgenes(positions_LV, TCR)
# positions is the final information of AA relations
# TCR is the information gathered for the initial analysis
checkVgenes <- function(positions, TCR) {
count <- NULL
for (i in seq_len(nrow(positions))) {
a <- positions[i,"To"]
b <- positions[i,"From"]
x <- TCR[which(TCR[,"Var1"] == a), "vgene"]
y <- TCR[which(TCR[,"Var1"] == b), "vgene"]
if (x[1] == y[1]) {
next()
} else {
count <- c(count,i)
}
}
if (length(count) > 0) {
positions <- positions[-count,]
}
return(positions)
}
checkVgenes(positions_LV, TCR)
calculateConvergence <- function(combined, chain = "TCRB", group = NULL,
motif.length = 3, num.cores =2, boot.straps = 1000,
p.value.motif = 0.001, fc.motif = 5) {
tmp.list <- parsingContigList(combined, group = group)
load("./data/pbmcControls.rda")
controls <- getTCR(pbmc, "TCRB")
for (x in seq_along(tmp.list)) {
tmp <- tmp.list[[x]]
TCR <- getTCR(tmp, chain)
message(paste("Calculating Global Convergence in:", names(tmp.list)[x]))
positions_LV <- globalConvergence(tmp, chain = chain)
positions_LV <- checkVgenes(positions_LV, TCR)
message(paste("Calculating Local Convergence in:", names(tmp.list)[x]))
positions_motif <- localConvergence(tmp, chain = chain, motif.length=motif.length)
message(paste("Bootstrapping Random Global Convergence in:", names(tmp.list)[x]))
bootstrap_gc <- pbmclapply(1:boot.straps, sampleControl_gc, mc.cores = num.cores)
message(paste("Bootstrapping Random Local Convergence in:", names(tmp.list)[x]))
bootstrap_lc <- pbmclapply(1:boot.straps, sampleControl_lc, mc.cores = num.cores)
message(paste("Filtering Bootstrapped Local Convergence in:", names(tmp.list)[x]))
#Make single data frame of motifs in bootstrap values
x <- lapply(bootstrap_lc, function(x){data.frame(x)})
df <- suppressWarnings(Reduce(function(x, y) merge(x=x, y=y, by="Var1", all.x=T, all.y=T), x))
df[is.na(df)] <- 0
##for each motif, calculate p-value and fold-change
table <- as.data.frame(table(positions_motif$spec.Motif))
for (i in seq_len(nrow(table))) {
vector <- df[table[,"Var1"][i], 2:ncol(df)]
number <- table[i,"Freq"]
table$p[i] <- length(vector[vector >= number])/length(vector)
table$fc[i] <- number/median(as.numeric(vector))
}
#Filter out motifs based on p-value and fold-change
table <- table[table$p <= p.value.motif & table$fc >= fc.motif,]
positions_motif <- positions_motif[positions_motif$spec.Motif %in% table$Var1,]
edges <- rbind.data.frame(positions_LV, positions_motif[,c(1,2,4)])
vertices <- as.data.frame(TCR$Var1)
g = graph_from_data_frame(edges, directed = FALSE, vertices = vertices)
lou <- components(g, mode = "weak")
test <- as.data.frame(table(lou$membership))
clusters <- components(g, mode = "strong")
membership <- data.frame(cdr3 = names(clusters$membership), TCRcluster = clusters$membership)
membership$TCRcluster <- paste0(names(tmp.list)[x], "_", membership$TCRcluster)
membership <- merge(membership, TCR, by.x = "cdr3", by.y = "Var1")
motifs <- positions_motif %>%
group_by(To) %>%
summarise(filtered.motifs = paste(unique(spec.Motif), collapse = ','))
membership <- merge(membership, motifs, by.x = "cdr3", by.y = "To")
tmp <- merge(tmp, membership, by.x = chainCheck(chain)[[1]], by.y = "cdr3")
tmp.list[[x]] <- tmp
}
return(tmp.list)
}
testRun <- calculateConvergence(combined, chain = "TCRB", group = "sample",
motif.length = 3, num.cores =3, boot.straps = 1000,
p.value.motif = 0.001, fc.motif = 5)
testRun <- calculateConvergence(combined, chain = "TCRB", group = "Patient",
motif.length = 3, num.cores =3, boot.straps = 1000,
p.value.motif = 0.001, fc.motif = 5)
vertices <- unique(as.data.frame(TCR$Var1))
g = graph_from_data_frame(edges, directed = FALSE, vertices = vertices)
calculateConvergence <- function(combined, chain = "TCRB", group = NULL,
motif.length = 3, num.cores =2, boot.straps = 1000,
p.value.motif = 0.001, fc.motif = 5) {
tmp.list <- parsingContigList(combined, group = group)
load("./data/pbmcControls.rda")
controls <- getTCR(pbmc, "TCRB")
for (x in seq_along(tmp.list)) {
tmp <- tmp.list[[x]]
TCR <- getTCR(tmp, chain)
message(paste("Calculating Global Convergence in:", names(tmp.list)[x]))
positions_LV <- globalConvergence(tmp, chain = chain)
positions_LV <- checkVgenes(positions_LV, TCR)
message(paste("Calculating Local Convergence in:", names(tmp.list)[x]))
positions_motif <- localConvergence(tmp, chain = chain, motif.length=motif.length)
message(paste("Bootstrapping Random Global Convergence in:", names(tmp.list)[x]))
bootstrap_gc <- pbmclapply(1:boot.straps, sampleControl_gc, mc.cores = num.cores)
message(paste("Bootstrapping Random Local Convergence in:", names(tmp.list)[x]))
bootstrap_lc <- pbmclapply(1:boot.straps, sampleControl_lc, mc.cores = num.cores)
message(paste("Filtering Bootstrapped Local Convergence in:", names(tmp.list)[x]))
#Make single data frame of motifs in bootstrap values
x <- lapply(bootstrap_lc, function(x){data.frame(x)})
df <- suppressWarnings(Reduce(function(x, y) merge(x=x, y=y, by="Var1", all.x=T, all.y=T), x))
df[is.na(df)] <- 0
##for each motif, calculate p-value and fold-change
table <- as.data.frame(table(positions_motif$spec.Motif))
for (i in seq_len(nrow(table))) {
vector <- df[table[,"Var1"][i], 2:ncol(df)]
number <- table[i,"Freq"]
table$p[i] <- length(vector[vector >= number])/length(vector)
table$fc[i] <- number/median(as.numeric(vector))
}
#Filter out motifs based on p-value and fold-change
table <- table[table$p <= p.value.motif & table$fc >= fc.motif,]
positions_motif <- positions_motif[positions_motif$spec.Motif %in% table$Var1,]
edges <- rbind.data.frame(positions_LV, positions_motif[,c(1,2,4)])
vertices <- unique(as.data.frame(TCR$Var1))
g = graph_from_data_frame(edges, directed = FALSE, vertices = vertices)
clusters <- components(g, mode = "strong")
membership <- data.frame(cdr3 = names(clusters$membership), TCRcluster = clusters$membership)
membership$TCRcluster <- paste0(names(tmp.list)[x], "_", membership$TCRcluster)
membership <- merge(membership, TCR, by.x = "cdr3", by.y = "Var1")
motifs <- positions_motif %>%
group_by(To) %>%
summarise(filtered.motifs = paste(unique(spec.Motif), collapse = ','))
membership <- merge(membership, motifs, by.x = "cdr3", by.y = "To")
tmp <- merge(tmp, membership, by.x = chainCheck(chain)[[1]], by.y = "cdr3")
tmp.list[[x]] <- tmp
}
return(tmp.list)
}
testRun <- calculateConvergence(combined, chain = "TCRB", group = "Patient",
motif.length = 3, num.cores =3, boot.straps = 1000,
p.value.motif = 0.001, fc.motif = 5)
View(TCR)
View(pbmc)
motifs <- positions_motif %>%
group_by(To) %>%
summarise(filtered.motifs = paste(unique(spec.Motif), collapse = ','))
membership <- merge(membership, motifs, by.x = "cdr3", by.y = "To")
tmp <- merge(tmp, membership, by.x = chainCheck(chain)[[1]], by.y = "cdr3")
tmp.list[[x]] <- tmp
View(tmp.list)
tmp.list[[1]]
tmp.list[[x]] <- tmp
head(tmp.list[[x]])
head(tmp.list[[1]])
# positions is the final information of AA relations
# TCR is the information gathered for the initial analysis
checkVgenes <- function(positions, TCR) {
count <- NULL
for (i in seq_len(nrow(positions))) {
a <- positions[i,"To"]
b <- positions[i,"From"]
d <- TCR[which(TCR[,"Var1"] == a), "vgene"]
e <- TCR[which(TCR[,"Var1"] == b), "vgene"]
if (d[1] == e[1]) {
next()
} else {
count <- c(count,i)
}
}
if (length(count) > 0) {
positions <- positions[-count,]
}
return(positions)
}
x <- 1
tmp.list[[x]] <- tmp
source("./R/functions.R")
setwd("~/Documents/GitHub/lg_dataAnalysis")
testRun <- calculateConvergence(combined, chain = "TCRB", group = "Patient",
motif.length = 3, num.cores =3, boot.straps = 1000,
p.value.motif = 0.001, fc.motif = 5)
names(tmp.list)
names(tmp.list)[x]
#Make single data frame of motifs in bootstrap values
df <- lapply(bootstrap_lc, function(x){data.frame(x)})
df <- suppressWarnings(Reduce(function(x, y) merge(x=df, y=y, by="Var1", all.x=T, all.y=T), df))
#Make single data frame of motifs in bootstrap values
df <- lapply(bootstrap_lc, function(x){data.frame(x)})
df <- suppressWarnings(Reduce(function(x, y) merge(x=df, y=y, by="Var1", all.x=T, all.y=T), x))
#Make single data frame of motifs in bootstrap values
df <- lapply(bootstrap_lc, function(x){data.frame(x)})
df <- suppressWarnings(Reduce(function(df, y) merge(df=df, y=y, by="Var1", all.x=T, all.y=T), df))
df <- suppressWarnings(Reduce(function(x, y) merge(x=df, y=y, by="Var1", all.x=T, all.y=T), x))
#Make single data frame of motifs in bootstrap values
z <- lapply(bootstrap_lc, function(x){data.frame(x)})
df <- suppressWarnings(Reduce(function(x, y) merge(x=z, y=y, by="Var1", all.x=T, all.y=T), x))
df <- suppressWarnings(Reduce(function(x, y) merge(x=z, y=y, by="Var1", all.x=T, all.y=T), z))
#Make single data frame of motifs in bootstrap values
x <- lapply(bootstrap_lc, function(x){data.frame(x)})
df <- suppressWarnings(Reduce(function(x, y) merge(x=x, y=y, by="Var1", all.x=T, all.y=T), x))
x <- 1
le <- x
#Make single data frame of motifs in bootstrap values
x <- lapply(bootstrap_lc, function(x){data.frame(x)})
df <- suppressWarnings(Reduce(function(x, y) merge(x=x, y=y, by="Var1", all.x=T, all.y=T), x))
df[is.na(df)] <- 0
##for each motif, calculate p-value and fold-change
table <- as.data.frame(table(positions_motif$spec.Motif))
for (i in seq_len(nrow(table))) {
vector <- df[table[,"Var1"][i], 2:ncol(df)]
number <- table[i,"Freq"]
table$p[i] <- length(vector[vector >= number])/length(vector)
table$fc[i] <- number/median(as.numeric(vector))
}
#Filter out motifs based on p-value and fold-change
table <- table[table$p <= p.value.motif & table$fc >= fc.motif,]
positions_motif <- positions_motif[positions_motif$spec.Motif %in% table$Var1,]
edges <- rbind.data.frame(positions_LV, positions_motif[,c(1,2,4)])
vertices <- unique(as.data.frame(TCR$Var1))
g = graph_from_data_frame(edges, directed = FALSE, vertices = vertices)
clusters <- components(g, mode = "strong")
membership <- data.frame(cdr3 = names(clusters$membership), TCRcluster = clusters$membership)
membership$TCRcluster <- paste0(names(tmp.list)[le], "_", membership$TCRcluster)
membership <- merge(membership, TCR, by.x = "cdr3", by.y = "Var1")
motifs <- positions_motif %>%
group_by(To) %>%
summarise(filtered.motifs = paste(unique(spec.Motif), collapse = ','))
membership <- merge(membership, motifs, by.x = "cdr3", by.y = "To")
tmp <- merge(tmp, membership, by.x = chainCheck(chain)[[1]], by.y = "cdr3")
calculateConvergence <- function(combined, chain = "TCRB", group = NULL,
motif.length = 3, num.cores =2, boot.straps = 1000,
p.value.motif = 0.001, fc.motif = 5) {
tmp.list <- parsingContigList(combined, group = group)
load("./data/pbmcControls.rda")
controls <- getTCR(pbmc, "TCRB")
for (x in seq_along(tmp.list)) {
le <- x
tmp <- tmp.list[[x]]
TCR <- getTCR(tmp, chain)
message(paste("Calculating Global Convergence in:", names(tmp.list)[x]))
positions_LV <- globalConvergence(tmp, chain = chain)
positions_LV <- checkVgenes(positions_LV, TCR)
message(paste("Calculating Local Convergence in:", names(tmp.list)[x]))
positions_motif <- localConvergence(tmp, chain = chain, motif.length=motif.length)
message(paste("Bootstrapping Random Global Convergence in:", names(tmp.list)[x]))
bootstrap_gc <- pbmclapply(1:boot.straps, sampleControl_gc, mc.cores = num.cores)
message(paste("Bootstrapping Random Local Convergence in:", names(tmp.list)[x]))
bootstrap_lc <- pbmclapply(1:boot.straps, sampleControl_lc, mc.cores = num.cores)
message(paste("Filtering Bootstrapped Local Convergence in:", names(tmp.list)[x]))
#Make single data frame of motifs in bootstrap values
x <- lapply(bootstrap_lc, function(x){data.frame(x)})
df <- suppressWarnings(Reduce(function(x, y) merge(x=x, y=y, by="Var1", all.x=T, all.y=T), x))
df[is.na(df)] <- 0
##for each motif, calculate p-value and fold-change
table <- as.data.frame(table(positions_motif$spec.Motif))
for (i in seq_len(nrow(table))) {
vector <- df[table[,"Var1"][i], 2:ncol(df)]
number <- table[i,"Freq"]
table$p[i] <- length(vector[vector >= number])/length(vector)
table$fc[i] <- number/median(as.numeric(vector))
}
#Filter out motifs based on p-value and fold-change
table <- table[table$p <= p.value.motif & table$fc >= fc.motif,]
positions_motif <- positions_motif[positions_motif$spec.Motif %in% table$Var1,]
edges <- rbind.data.frame(positions_LV, positions_motif[,c(1,2,4)])
vertices <- unique(as.data.frame(TCR$Var1))
g = graph_from_data_frame(edges, directed = FALSE, vertices = vertices)
clusters <- components(g, mode = "strong")
membership <- data.frame(cdr3 = names(clusters$membership), TCRcluster = clusters$membership)
membership$TCRcluster <- paste0(names(tmp.list)[le], "_", membership$TCRcluster)
membership <- merge(membership, TCR, by.x = "cdr3", by.y = "Var1")
motifs <- positions_motif %>%
group_by(To) %>%
summarise(filtered.motifs = paste(unique(spec.Motif), collapse = ','))
membership <- merge(membership, motifs, by.x = "cdr3", by.y = "To")
tmp <- merge(tmp, membership, by.x = chainCheck(chain)[[1]], by.y = "cdr3")
tmp.list[[le]] <- tmp
}
return(tmp.list)
}
testRun <- calculateConvergence(combined, chain = "TCRB", group = "Patient",
motif.length = 3, num.cores =3, boot.straps = 1000,
p.value.motif = 0.001, fc.motif = 5)
View(x)
motifs <- positions_motif %>%
group_by(To) %>%
suppressMessages(summarise(filtered.motifs = paste(unique(spec.Motif), collapse = ',')))
View(motifs)
test <- bind_rows(testRun)
View(test)
library(ape)
dist.aa(head(tmp$cdr3_aa2))
dist.aa(head(as.AAbin(tmp$cdr3_aa2)))
y <- as.AAbin(tmp$cdr3_aa2)))
y <- as.AAbin(tmp$cdr3_aa2))
y <- as.AAbin(tmp$cdr3_aa2)
y <- dist.aa(y)
head(y)
y
data(woodmouse)
AA <- trans(woodmouse, 2)
y <- tmp$cdr3_aa2
y <- as.AAbin.character(y)
y <- tmp$cdr3_aa2
y <- as.AAbin(y)
y <- tmp$cdr3_aa2
y <- as.AAbin.AAstring(y)
y <- tmp$cdr3_aa2
y <- AAbin(y)
y <- tmp$cdr3_aa2
y <- masa(y)
y <- msa(y)
y <- rbind.AAbin(y)
y <- as.AAbin(y)
y <- tmp$cdr3_aa2
y <- as.AAbin(y)
y <- tmp$cdr3_aa2
y <- as.AAbin(y, i = length(y))
y <- tmp$cdr3_aa2
y <- as.AAbin(y, i = length(y))
y <- tmp$cdr3_aa2
y <- as.AAbin(y, j = length(y))
y <- as.AAbin(y, recursive = F)
y <- tmp$cdr3_aa2
y <- as.AAbin(y, recursive = F)
y <- AAbin(y, recursive = F)
y <- as.AAbin.character(y, recursive = F)
y <- tmp$cdr3_aa2
y <- as.AAbin.character(y, recursive = F)
y <- as.AAbin.character(y, i = length(y))
y <- tmp$cdr3_aa2
y <- as.AAbin.character(y, i = length(y))
y <- tmp$cdr3_aa2
y <- as.AAbin.character(y, j = length(y))
BiocManager::install("msa"
)
y <- tmp$cdr3_aa2
y <- unique(y)
align <-  msa(y, type = "AA")
library(msa)
align <-  msa(y, type = "AA")
align <-  msa(y, type = "protein")
align <- msaConvert(align, type="ape::AAbin")
align <-  msa(y, type = "protein")
align <- msaConvert(align, type="ape::AAbin")
align <-  msa(y, type = "protein")
align2 <- msaConvert(align, type="ape::AAbin")
head(align2)
head(align)
align
align <-  msa(y, type = "protein", method="ClustalOmega")
align <-  msa(y, type = "protein", method="ClustalOmega")
align
align <-  msa(y, type = "protein", method="Muscle")
align
align <-  msa(y, type = "protein", gapOpening = 15)
align
align <-  msa(y, type = "protein", gapOpening = 20)
align2 <- msaConvert(align, type="ape::AAbin")
align
align2 <- msaConvert(align, type="ape::AAbin")
y <- dist.aa(align2)
y
y <- dist.aa(align2, scaled = TRUE)
y <- dist.aa(align2, scaled = TRUE)
head(y)
align <-  msa(y, type = "protein", gapOpening = 15)
y <- tmp$cdr3_aa2
y <- unique(y)
align <-  msa(y, type = "protein", gapOpening = 15)
align2 <- msaConvert(align, type="ape::AAbin")
z <- dist.aa(align2, scaled = TRUE)
head(z)
z <- dist.aa(align, scaled = TRUE)
df <- data.frame(cdr3 = y, scaled.distance = dist.aa(align2, scaled = TRUE))
z <- dist.aa(align2, scaled = TRUE)
1 + NULL
1+1
